classdef PathFollowingRobot < handle
    properties
        SerialPort
        Waypoints
        CurrentWaypointIndex
        FuzzySystem
        Running
        MapFigure
        PathPlot
        RobotPlot
        WaypointPlot
        LastPositionTime
        PositionHistory
        LinearSpeed = 0.3333 % meters per second
        DeltaT = 0.775 % seconds
        MaxPWM = 255
    end
    
    methods
        function obj = PathFollowingRobot(portName)
            % Initialize serial port
            obj.SerialPort = serialport(portName, 115200);
            configureTerminator(obj.SerialPort, "LF");
            flush(obj.SerialPort);
            
            % Load waypoints
            obj.Waypoints = [
                7.214920000, 124.249217000; 7.214920006, 124.249217231; 
                7.214920012, 124.249217462; 7.214920018, 124.249217694;
                7.214920024, 124.249217925; 7.214920030, 124.249218156;
                7.214920036, 124.249218387; 7.214920042, 124.249218618;
                7.214920048, 124.249218849; 7.214920054, 124.249219080;
                7.214920060, 124.249219311; 7.214920066, 124.249219542;
            ];
            
            obj.CurrentWaypointIndex = 1;
            obj.Running = false;
            obj.PositionHistory = [];
            obj.LastPositionTime = datetime('now');
            
            % Initialize fuzzy logic system
            try
                obj.FuzzySystem = obj.create3DFuzzySystem();
                disp('Fuzzy system successfully initialized');
            catch ME
                error('Failed to initialize fuzzy system: %s', ME.message);
            end
            
            % Initialize map visualization
            obj.initializeMap();
            disp('Robot initialized and ready to run');
        end
        
        function initializeMap(obj)
            obj.MapFigure = figure('Name', 'Robot Path Monitoring', 'NumberTitle', 'off');
            
            [lat, lon] = obj.convertToNumeric(obj.Waypoints);
            obj.WaypointPlot = geoplot(lat, lon, 'g-', 'LineWidth', 2);
            hold on;
            obj.WaypointPlot = geoscatter(lat, lon, 'filled', 'MarkerFaceColor', 'red');
            
            obj.PathPlot = geoplot(lat(1), lon(1), 'b-', 'LineWidth', 1.5);
            obj.RobotPlot = geoscatter(lat(1), lon(1), 100, 'filled', 'MarkerFaceColor', 'blue');
            
            geobasemap('satellite');
            title('Robot Path Monitoring');
            legend('Planned Path', 'Waypoints', 'Robot Path', 'Robot Position');
            drawnow;
        end
        
        function [lat, lon] = convertToNumeric(~, waypoints)
            lat = waypoints(:,1);
            lon = waypoints(:,2);
        end
        
        function updateMap(obj, currentLat, currentLon)
            xData = obj.PathPlot.XData;
            yData = obj.PathPlot.YData;
            
            obj.PathPlot.XData = [xData, currentLat];
            obj.PathPlot.YData = [yData, currentLon];
            obj.PositionHistory = [obj.PositionHistory; currentLat, currentLon];
            
            obj.RobotPlot.LatitudeData = currentLat;
            obj.RobotPlot.LongitudeData = currentLon;
            
            targetLat = obj.Waypoints(obj.CurrentWaypointIndex, 1);
            targetLon = obj.Waypoints(obj.CurrentWaypointIndex, 2);
            geoscatter(targetLat, targetLon, 100, 'filled', 'MarkerFaceColor', 'yellow');
            
            latLim = [min([currentLat; obj.Waypoints(:,1)])-0.0001, max([currentLat; obj.Waypoints(:,1)])+0.0001];
            lonLim = [min([currentLon; obj.Waypoints(:,2)])-0.0001, max([currentLon; obj.Waypoints(:,2)])+0.0001];
            geolimits(latLim, lonLim);
            
            drawnow;
        end
        
        function start(obj)
            obj.Running = true;
            obj.run();
        end
        
        function stop(obj)
            obj.Running = false;
            writeline(obj.SerialPort, "CMD:0,0");
        end
        
        function run(obj)
            while obj.Running
                if obj.SerialPort.NumBytesAvailable > 0
                    data = readline(obj.SerialPort);
                    
                    if startsWith(data, "GPS:")
                        try
                            gpsData = sscanf(data, "GPS:%f,%f,%f,%f");
                            if length(gpsData) == 4
                                currentLat = gpsData(1);
                                currentLon = gpsData(2);
                                speed = gpsData(3);
                                heading = gpsData(4);
                                
                                obj.updateMap(currentLat, currentLon);
                                
                                % Get current target waypoint
                                target = obj.Waypoints(obj.CurrentWaypointIndex, :);
                                
                                % Calculate errors (scaled by 1e6 for fuzzy logic)
                                xError = (target(1) - currentLat) * 1e6;  % Latitude error
                                yError = (target(2) - currentLon) * 1e6;  % Longitude error
                                distance = sqrt(xError^2 + yError^2) / 1e6;
                                
                                % Calculate bearing and heading error
                                bearing = obj.calculateBearing(currentLat, currentLon, target(1), target(2));
                                headingError = obj.wrapTo180(bearing - heading);
                                
                                % Check if reached waypoint
                                if distance < max(0.00001, obj.LinearSpeed * obj.DeltaT/2)
                                    obj.CurrentWaypointIndex = min(obj.CurrentWaypointIndex + 1, size(obj.Waypoints, 1));
                                    if obj.CurrentWaypointIndex == size(obj.Waypoints, 1)
                                        obj.stop();
                                        disp('Final waypoint reached!');
                                        return;
                                    end
                                    continue;
                                end
                                
                                % Fuzzy logic control
                                try
                                    inputs = [xError, yError, headingError];
                                    outputs = evalfis(obj.FuzzySystem, inputs);
                                    
                                    % Scale outputs to PWM range
                                    leftPWM = round(outputs(1));
                                    rightPWM = round(outputs(2));
                                    
                                    % Apply speed scaling based on distance
                                    speedScale = min(1, max(0.3, distance*1e5));
                                    leftPWM = round(leftPWM * speedScale);
                                    rightPWM = round(rightPWM * speedScale);
                                    
                                    % Constrain PWM values
                                    leftPWM = max(-obj.MaxPWM, min(obj.MaxPWM, leftPWM));
                                    rightPWM = max(-obj.MaxPWM, min(obj.MaxPWM, rightPWM));
                                    
                                    % Send motor commands
                                    cmdStr = sprintf("CMD:%d,%d", leftPWM, rightPWM);
                                    writeline(obj.SerialPort, cmdStr);
                                catch ME
                                    fprintf('Fuzzy logic error: %s\n', ME.message);
                                    writeline(obj.SerialPort, "CMD:0,0");
                                end
                            end
                        catch ME
                            fprintf('Error processing GPS data: %s\n', ME.message);
                        end
                    end
                end
                pause(0.1);
            end
        end
        
        function fis = create3DFuzzySystem(obj)
            % Create new 3-input FIS
            fis = mamfis('Name', 'path_following_3d');
            
            % Add xError (latitude error) input
            fis = addInput(fis, [-5 5], 'Name', 'xError');
            fis = addMF(fis, 'xError', 'trimf', [-5 -5 -1.67], 'Name', 'Left');
            fis = addMF(fis, 'xError', 'trimf', [-2.5 0 2.5], 'Name', 'Center');
            fis = addMF(fis, 'xError', 'trimf', [1.67 5 5], 'Name', 'Right');
            
            % Add yError (longitude error) input
            fis = addInput(fis, [-5 5], 'Name', 'yError');
            fis = addMF(fis, 'yError', 'trimf', [-5 -5 -1.67], 'Name', 'Behind');
            fis = addMF(fis, 'yError', 'trimf', [-2.5 0 2.5], 'Name', 'Center');
            fis = addMF(fis, 'yError', 'trimf', [1.67 5 5], 'Name', 'Ahead');
            
            % Add heading_error input
            fis = addInput(fis, [-180 180], 'Name', 'heading_error');
            fis = addMF(fis, 'heading_error', 'trimf', [-180 -180 -60], 'Name', 'Left');
            fis = addMF(fis, 'heading_error', 'trimf', [-90 0 90], 'Name', 'Straight');
            fis = addMF(fis, 'heading_error', 'trimf', [60 180 180], 'Name', 'Right');
            
            % Add pwm_left output
            fis = addOutput(fis, [-obj.MaxPWM obj.MaxPWM], 'Name', 'pwm_left');
            fis = addMF(fis, 'pwm_left', 'trimf', [-255 -255 -85], 'Name', 'Reverse');
            fis = addMF(fis, 'pwm_left', 'trimf', [-170 0 170], 'Name', 'Stop');
            fis = addMF(fis, 'pwm_left', 'trimf', [85 255 255], 'Name', 'Forward');
            
            % Add pwm_right output
            fis = addOutput(fis, [-obj.MaxPWM obj.MaxPWM], 'Name', 'pwm_right');
            fis = addMF(fis, 'pwm_right', 'trimf', [-255 -255 -85], 'Name', 'Reverse');
            fis = addMF(fis, 'pwm_right', 'trimf', [-170 0 170], 'Name', 'Stop');
            fis = addMF(fis, 'pwm_right', 'trimf', [85 255 255], 'Name', 'Forward');
            
            % Rule Base - 3x3x3 = 27 rules
            ruleList = [
            1 1 1, 3 1, 1 1;   % Left, Behind, Left heading - Forward Left, Reverse Right
            1 1 2, 3 2, 1 1;   % Left, Behind, Straight - Forward Left, Stop Right
            1 1 3, 3 3, 1 1;   % Left, Behind, Right - Forward Left, Forward Right
            
            1 2 1, 3 1, 1 1;   % Left, Center, Left heading
            1 2 2, 3 2, 1 1;   % Left, Center, Straight
            1 2 3, 3 3, 1 1;   % Left, Center, Right
            
            1 3 1, 3 1, 1 1;   % Left, Ahead, Left heading
            1 3 2, 3 2, 1 1;   % Left, Ahead, Straight
            1 3 3, 3 3, 1 1;   % Left, Ahead, Right
            
            2 1 1, 1 3, 1 1;   % Center, Behind, Left heading - Reverse Left, Forward Right
            2 1 2, 3 3, 1 1;   % Center, Behind, Straight - Forward both
            2 1 3, 3 1, 1 1;   % Center, Behind, Right heading - Forward Right, Reverse Left
            
            2 2 1, 2 2, 1 1;   % Center, Center, Left heading - Stop both
            2 2 2, 2 2, 1 1;   % Center, Center, Straight - Stop both
            2 2 3, 2 2, 1 1;   % Center, Center, Right heading - Stop both
            
            2 3 1, 3 3, 1 1;   % Center, Ahead, Left heading - Forward both
            2 3 2, 3 3, 1 1;   % Center, Ahead, Straight - Forward both
            2 3 3, 3 3, 1 1;   % Center, Ahead, Right heading - Forward both
            
            3 1 1, 1 3, 1 1;   % Right, Behind, Left heading - Reverse Left, Forward Right
            3 1 2, 2 3, 1 1;   % Right, Behind, Straight - Stop Left, Forward Right
            3 1 3, 1 3, 1 1;   % Right, Behind, Right heading - Reverse Left, Forward Right
            
            3 2 1, 1 3, 1 1;   % Right, Center, Left heading
            3 2 2, 1 3, 1 1;   % Right, Center, Straight
            3 2 3, 1 3, 1 1;   % Right, Center, Right heading
            
            3 3 1, 1 3, 1 1;   % Right, Ahead, Left heading
            3 3 2, 1 3, 1 1;   % Right, Ahead, Straight
            3 3 3, 1 3, 1 1;   % Right, Ahead, Right heading
            ];
            
            fis = addRule(fis, ruleList);
        end
        
        function distance = calculateDistance(~, lat1, lon1, lat2, lon2)
            R = 6371000; % Earth radius in meters
            dLat = deg2rad(lat2-lat1);
            dLon = deg2rad(lon2-lon1);
            a = sin(dLat/2) * sin(dLat/2) + ...
                cos(deg2rad(lat1)) * cos(deg2rad(lat2)) * ...
                sin(dLon/2) * sin(dLon/2);
            c = 2 * atan2(sqrt(a), sqrt(1-a));
            distance = R * c;
        end
        
        function bearing = calculateBearing(~, lat1, lon1, lat2, lon2)
            lat1 = deg2rad(lat1);
            lon1 = deg2rad(lon1);
            lat2 = deg2rad(lat2);
            lon2 = deg2rad(lon2);
            
            y = sin(lon2-lon1) * cos(lat2);
            x = cos(lat1)*sin(lat2) - sin(lat1)*cos(lat2)*cos(lon2-lon1);
            bearing = rad2deg(atan2(y, x));
        end
        
        function angle = wrapTo180(~, angle)
            angle = mod(angle + 180, 360) - 180;
        end
        
        function delete(obj)
            if obj.Running
                obj.stop();
            end
            clear obj.SerialPort;
        end
    end
end
